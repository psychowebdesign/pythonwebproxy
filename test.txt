GET / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:44.0) Gecko/20100101 Firefox/44.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Cookie: BIGipServerZebedee=90220736.20480.0000; TS01237438=01700654a66aed1325bafa0314bc4288022b148d529bed788ac9aa254c794d92002b7508e4ad6b936465412034eb6d95a58aa895aa
Connection: keep-alive


#context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
forward = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
forward = ssl.wrap_socket(forward,
		ca_certs='/usr/local/lib/python2.7/dist-packages/requests/cacert.pem',
		cert_reqs=ssl.CERT_REQUIRED)
print "->>>>>"
print host
forward.connect((host, 443))
forward.send(get_req)



print "hererererer sock ssl"
print get_req
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
forward = ssl.wrap_socket(s,
		ca_certs="/usr/local/lib/python2.7/dist-packages/requests/cacert.pem",
		cert_reqs=ssl.CERT_REQUIRED)
forward.connect((host, 443))
forward.send("""GET / HTTP/1.0\r\nHost: %s\r\n\r\n"""%(host))
data = forward.recv()
sock.send(data)
print "herererer dave"
try:
		#sock = ssl.wrap_socket(sock, server_side=True, certfile="server.crt", keyfile="server.key")
		print "wrapped up"
except Exception, e:
		print e

while len(data) > 0:
				print "dddddddddddddd"
				data = forward.recv()
				sock.send(data)
				print data
# note that closing the SSLSocket will also close the underlying socket
#forward.close()
sock.close()


GET / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:44.0) Gecko/20100101 Firefox/44.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Cookie: BIGipServerZebedee=90220736.20480.0000; TS01237438=01700654a66aed1325bafa0314bc4288022b148d529bed788ac9aa254c794d92002b7508e4ad6b936465412034eb6d95a58aa895aa
Connection: keep-alive

HTTP/1.1 200 Connection established
Proxy-agent: Python Proxy

HTTP/1.1 200 Connection established
Proxy-agent: Python Proxy

GET / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:44.0) Gecko/20100101 Firefox/44.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Cookie: BIGipServerZebedee=90220736.20480.0000; TS01237438=01700654a66aed1325bafa0314bc4288022b148d529bed788ac9aa254c794d92002b7508e4ad6b936465412034eb6d95a58aa895aa
Connection: keep-alive

HTTP/1.1 200 OK
Content-Encoding: gzip
Cache-Control: max-age=604800
Content-Type: text/html
Date: Mon, 22 Feb 2016 13:07:04 GMT
Etag: "359670651+gzip"
Expires: Mon, 29 Feb 2016 13:07:04 GMT
Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
Server: ECS (iad/18CB)
Vary: Accept-Encoding0
X-Cache: HIT
x-ec-custom-error: 1
Content-Length: 606


HTTP/1.1 200 OK
Content-Encoding: gzip
Cache-Control: max-age=604800
Content-Type: text/html
Date: Mon, 22 Feb 2016 13:14:15 GMT
Etag: "359670651+gzip"
Expires: Mon, 29 Feb 2016 13:14:15 GMT
Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
Server: ECS (iad/182A)
Vary: Accept-Encoding
X-Cache: HIT
x-ec-custom-error: 1
Content-Length: 606


Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p
'%a, %d %b %Y %I:%M:%S GMT'

#cur_dir = os.path.dirname(os.path.realpath(__file__))
#self.cache_dir = cur_dir + "/cache"
#if not os.path.exists(self.cache_dir):
#    os.makedirs(self.cache_dir)

cur_dir = os.path.dirname(os.path.realpath(__file__))
self.cache_dir = cur_dir + "/cache"
if not os.path.exists(self.cache_dir):
		os.makedirs(self.cache_dir)



		"""
		if self.ok_response_header(data):
				print "new ok response"
				resp_h = response_header(data)
				client_sock = self.socket_directions[sock]
				client_dest_url = self.server_socket_path[sock]
				print "1", sock
				print "2", client_sock
				print "resp_h %s dest %s"%(str(resp_h.get('expires_datetime')), client_dest_url)
				list_data = self.cache.search(client_dest_url, resp_h, sock)
				if list_data is not None:
						for chunk in list_data:
								client_sock.send(chunk)
						self.close_and_clean(sock)
						return
		"""
